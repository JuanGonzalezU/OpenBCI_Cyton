# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'main.ui'
#
# Created by: PyQt5 UI code generator 5.15.10
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again. Do not edit this file unless you know what you are doing.

# Import necessary components from PyQt5 for GUI creation
from PyQt5 import QtCore, QtGui, QtWidgets
from functions import *
import pyqtgraph as pg
from PyQt5.QtCore import QTimer
import numpy as np
import threading
import pygame
import sys
import random
import csv
import os
from datetime import datetime

class MainApp(QtWidgets.QWidget):  # or QtWidgets.QMainWindow depending on your need
    def __init__(self, parent=None):
        super(MainApp, self).__init__(parent)
        self.ui = Ui_Form()
        self.ui.setupUi(self)

    def closeEvent(self, event):
        self.ui.stop_pygame()  # Ensure Pygame is stopped when the window is closed
        event.accept()  # Proceed with the default close event


class Ui_Form(object):
    def setupUi(self, Form):

        self.is_streaming = False
        self.record_data = False

        # Create a QTimer object
        self.timer_update = QTimer()
        self.timer_update.timeout.connect(self.graphs) 

        self.timer_getdata = QTimer()
        self.timer_getdata.timeout.connect(self.get_data) 

        # Set the object name and resize the main form
        Form.setObjectName("Form")
        Form.resize(1245, 766)

        # Label for the COM port configuration
        self.label = QtWidgets.QLabel(Form)
        self.label.setGeometry(QtCore.QRect(30, 80, 47, 13))
        self.label.setObjectName("label")

        # Text input for COM port
        self.com_port = QtWidgets.QLineEdit(Form)
        self.com_port.setGeometry(QtCore.QRect(100, 80, 81, 20))
        self.com_port.setObjectName("com_port")

        # Button to initiate connection
        self.connect_button = QtWidgets.QPushButton(Form)
        self.connect_button.setGeometry(QtCore.QRect(20, 280, 75, 23))
        self.connect_button.setObjectName("connect_button")
        self.connect_button.clicked.connect(self.connect_board)

        # Text input for window size configuration
        self.win_size = QtWidgets.QLineEdit(Form)
        self.win_size.setGeometry(QtCore.QRect(100, 110, 81, 20))
        self.win_size.setText("")
        self.win_size.setObjectName("win_size")

        # Labels for window size and sample frequency
        self.label_2 = QtWidgets.QLabel(Form)
        self.label_2.setGeometry(QtCore.QRect(30, 110, 47, 13))
        self.label_2.setObjectName("label_2")
        
        self.label_3 = QtWidgets.QLabel(Form)
        self.label_3.setGeometry(QtCore.QRect(30, 140, 47, 13))
        self.label_3.setObjectName("label_3")

        # Button to reset the configuration
        self.reset_button = QtWidgets.QPushButton(Form)
        self.reset_button.setGeometry(QtCore.QRect(110, 280, 75, 23))
        self.reset_button.setObjectName("reset_button")
        self.reset_button.clicked.connect(self.reset_app)

        # Checkboxes for enabling different EEG channels
        self.BoxCh1 = QtWidgets.QCheckBox(Form)
        self.BoxCh1.setGeometry(QtCore.QRect(30, 180, 70, 17))
        self.BoxCh1.setObjectName("BoxCh1")
        self.BoxCh2 = QtWidgets.QCheckBox(Form)
        self.BoxCh2.setGeometry(QtCore.QRect(120, 180, 70, 17))
        self.BoxCh2.setObjectName("BoxCh2")
        self.BoxCh4 = QtWidgets.QCheckBox(Form)
        self.BoxCh4.setGeometry(QtCore.QRect(120, 200, 70, 17))
        self.BoxCh4.setObjectName("BoxCh4")
        self.BoxCh3 = QtWidgets.QCheckBox(Form)
        self.BoxCh3.setGeometry(QtCore.QRect(30, 200, 70, 17))
        self.BoxCh3.setObjectName("BoxCh3")
        self.BoxCh5 = QtWidgets.QCheckBox(Form)
        self.BoxCh5.setGeometry(QtCore.QRect(30, 220, 70, 17))
        self.BoxCh5.setObjectName("BoxCh5")
        self.BoxCh6 = QtWidgets.QCheckBox(Form)
        self.BoxCh6.setGeometry(QtCore.QRect(120, 220, 70, 17))
        self.BoxCh6.setObjectName("BoxCh6")
        self.BoxCh8 = QtWidgets.QCheckBox(Form)
        self.BoxCh8.setGeometry(QtCore.QRect(120, 240, 70, 17))
        self.BoxCh8.setObjectName("BoxCh8")
        self.BoxCh7 = QtWidgets.QCheckBox(Form)
        self.BoxCh7.setGeometry(QtCore.QRect(30, 240, 70, 17))
        self.BoxCh7.setObjectName("BoxCh7")

        # Update Frequnecy
        self.fps = QtWidgets.QLineEdit(Form)
        self.fps.setGeometry(QtCore.QRect(100, 140, 81, 20))
        self.fps.setText("")
        self.fps.setObjectName("fps")

        # Frames for displaying FFT and other data visualizations
        self.FFT_frame = QtWidgets.QFrame(Form)
        self.FFT_frame.setGeometry(QtCore.QRect(210, 80, 991, 271))
        self.FFT_frame.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.FFT_frame.setFrameShadow(QtWidgets.QFrame.Raised)
        self.FFT_frame.setObjectName("FFT_frame")
        # Additional frames for other data visualizations

        # Label for graph controls section
        self.label_4 = QtWidgets.QLabel(Form)
        self.label_4.setGeometry(QtCore.QRect(30, 320, 91, 20))
        self.label_4.setObjectName("label_4")

        # Checkboxes for different analysis types such as Filtering, FFT, PSD, and Time Domain
        self.BoxFiltering = QtWidgets.QCheckBox(Form)
        self.BoxFiltering.setGeometry(QtCore.QRect(30, 350, 70, 17))
        self.BoxFiltering.setObjectName("BoxFiltering")

        self.BoxFFT = QtWidgets.QCheckBox(Form)
        self.BoxFFT.setGeometry(QtCore.QRect(30, 370, 70, 17))
        self.BoxFFT.setObjectName("BoxFFT")

        self.BoxPSD = QtWidgets.QCheckBox(Form)
        self.BoxPSD.setGeometry(QtCore.QRect(30, 390, 70, 17))
        self.BoxPSD.setObjectName("BoxPSD")

        self.BoxTime = QtWidgets.QCheckBox(Form)
        self.BoxTime.setGeometry(QtCore.QRect(30, 410, 70, 17))
        self.BoxTime.setObjectName("BoxTime")

        self.BoxTest = QtWidgets.QCheckBox(Form)
        self.BoxTest.setGeometry(QtCore.QRect(30, 430, 70, 17))
        self.BoxTest.setObjectName("BoxTime")

        # Graph
        self.win = pg.GraphicsLayoutWidget(Form)  # Automatically generates grids with multiple items
        self.win.setGeometry(QtCore.QRect(210, 80, 991, 641))
        #self.win.setBackground('w') 
        
        # Add subgraphs
        self.TimeGraph = self.win.addPlot(row=0, col=0, colspan=2, title='Time Domain')
        self.FFTGraph = self.win.addPlot(row=1, col=0, title='PSD')
        self.PSD = self.win.addPlot(row=1, col=1, title='Power per Band') 
        self.win.setVisible(True)

        # Main title label for the EEG Analysis application
        self.label_5 = QtWidgets.QLabel(Form)
        self.label_5.setGeometry(QtCore.QRect(220, 30, 981, 31))
        font = QtGui.QFont()
        font.setPointSize(20)
        self.label_5.setFont(font)
        self.label_5.setLineWidth(1)
        self.label_5.setAlignment(QtCore.Qt.AlignCenter)
        self.label_5.setObjectName("label_5")

        # Footer label for the output section
        self.label_6 = QtWidgets.QLabel(Form)
        self.label_6.setGeometry(QtCore.QRect(210, 730, 991, 16))
        self.label_6.setObjectName("label_6")

        # Label for trial name
        self.label_7 = QtWidgets.QLabel(Form)
        self.label_7.setGeometry(QtCore.QRect(30, 690, 47, 13))
        self.label_7.setObjectName("label_7")

        # Text input for trial name
        self.trial_name = QtWidgets.QLineEdit(Form)
        self.trial_name.setGeometry(QtCore.QRect(90, 690, 81, 20))
        self.trial_name.setObjectName("trial_name")

        # Button to begin recording
        self.record_button = QtWidgets.QPushButton(Form)
        self.record_button.setGeometry(QtCore.QRect(20, 720, 75, 23))
        self.record_button.setObjectName("record_button")
        self.record_button.clicked.connect(self.begin_recording)

        # Button to end recording
        self.end_record_button = QtWidgets.QPushButton(Form)
        self.end_record_button.setGeometry(QtCore.QRect(100, 720, 75, 23))
        self.end_record_button.setObjectName("end_record_button")
        self.end_record_button.clicked.connect(self.end_recording)

        # Function to apply translations to all UI components
        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

        # Setup for pygame
        self.shared_beta_power = 30
        self.start_pygame_thread()

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "EEG Analysis Interface"))
        self.label.setText(_translate("Form", "COM Port"))
        self.connect_button.setText(_translate("Form", "Connect"))
        self.label_2.setText(_translate("Form", "Win. Size"))
        self.label_3.setText(_translate("Form", "FPS"))
        self.reset_button.setText(_translate("Form", "Reset"))
        self.BoxCh1.setText(_translate("Form", "Ch1"))
        self.BoxCh2.setText(_translate("Form", "Ch2"))
        self.BoxCh4.setText(_translate("Form", "Ch4"))
        self.BoxCh3.setText(_translate("Form", "Ch3"))
        self.BoxCh5.setText(_translate("Form", "Ch5"))
        self.BoxCh6.setText(_translate("Form", "Ch6"))
        self.BoxCh8.setText(_translate("Form", "Ch8"))
        self.BoxCh7.setText(_translate("Form", "Ch7"))
        self.label_4.setText(_translate("Form", "Graph Control"))
        self.BoxFiltering.setText(_translate("Form", "Filtering"))
        self.BoxFFT.setText(_translate("Form", "FFT"))
        self.BoxPSD.setText(_translate("Form", "PSD"))
        self.BoxTime.setText(_translate("Form", "Time D."))
        self.BoxTest.setText(_translate("Form", "Test"))
        self.label_5.setText(_translate("Form", "EEG Analysis"))
        self.label_6.setText(_translate("Form", "Outputs"))
        self.label_7.setText(_translate("Form", "Trial Name"))
        self.record_button.setText(_translate("Form", "Start"))
        self.end_record_button.setText(_translate("Form", "End"))

    def reset_app(self):
            # Reset all QLineEdit inputs to their default state
            self.com_port.clear()
            self.win_size.clear()
            self.fps.clear()
            self.trial_name.clear()

            # Uncheck all QCheckBox widgets
            self.BoxCh1.setChecked(False)
            self.BoxCh2.setChecked(False)
            self.BoxCh3.setChecked(False)
            self.BoxCh4.setChecked(False)
            self.BoxCh5.setChecked(False)
            self.BoxCh6.setChecked(False)
            self.BoxCh7.setChecked(False)
            self.BoxCh8.setChecked(False)
            self.BoxFiltering.setChecked(False)
            self.BoxFFT.setChecked(False)
            self.BoxPSD.setChecked(False)
            self.BoxTime.setChecked(False)
            self.BoxTest.setChecked(False)

            # Clear all graphical data
            self.TimeGraph.clear()
            self.FFTGraph.clear()
            self.PSD.clear()

            # Stop the stream if it is running
            if self.is_streaming:
                self.board.stop_stream()
                self.is_streaming = False  # Update streaming status
                self.label_6.setText('Streaming stopped.')

            # Stop any running timers if necessary
            self.timer_update.stop()
            self.timer_getdata.stop()

            # Update status label
            self.label_6.setText('All settings reset.')

    # Connect to the board

    def connect_board(self):
        
        self.label_6.setText('Connecting to Board...')
        
        # Preare board
        self.board, self.board_id, self.status = prepare_board(f'COM{self.com_port.text()}')

        # Change output
        self.label_6.setText(self.status)

        # Start data streamw
        self.initialize_and_start_stream()

    def initialize_and_start_stream(self):
        self.is_streaming = True

        # Start streaming data
        self.board.start_stream(45000)  # Modify as needed based on device capabilities

        # Get sampling rate
        self.fs = BoardShim.get_sampling_rate(self.board_id)

        # Get channels
        self.eeg_channels = BoardShim.get_eeg_channels(self.board_id)

        # Update UI
        self.label_6.setText('Connected and streaming data...')

        # Pre define bands
        self.bands = ['Delta','Theta','Alpha','Beta','Gamma']

        # Start the QTimer with interval specified in the window size input
        self.timer_getdata.start(int(1000 * 1/int(self.fps.text())))

    def get_data(self):
        
        # Start data stream based on the window size
        self.data = self.board.get_board_data()        
        self.eeg_data = self.data[self.eeg_channels, :]       

        # Change output
        self.label_6.setText('Streaming Data ...')

        # Based on selection choose the channels to use
        array_of_channels = [self.BoxCh1,self.BoxCh2,self.BoxCh3,self.BoxCh4,
                             self.BoxCh5,self.BoxCh6,self.BoxCh7,self.BoxCh8]
        
        # Boolean selection of channels
        selected_channels = [channel.isChecked() for channel in array_of_channels] 
        
        # Indices for selected EEG channels
        self.eeg_channel_indices = [index for index, value in enumerate(selected_channels) if value]

        # Data for selected EEG channels
        if hasattr(self, 'eeg_channel_data'):
            if self.eeg_channel_data.shape[0] == len(self.eeg_channel_indices):  
                self.eeg_channel_data = np.concatenate((self.eeg_channel_data,self.eeg_data[self.eeg_channel_indices, :]),axis = 1)
            else:
                self.eeg_channel_data = self.eeg_data[self.eeg_channel_indices, :]
        else:
            self.eeg_channel_data = self.eeg_data[self.eeg_channel_indices, :]

        # Take control over eeg_channel_data size.
        if self.eeg_channel_data.shape[1] > int(self.win_size.text())*self.fs:
            self.eeg_channel_data = self.eeg_channel_data[:,-int(int(self.win_size.text())*self.fs):] 
        
        # Graph results
        
        self.timer_update.start(int(1000 * 1/int(self.fps.text())))
        self.graphs()
        
    
    def graphs(self):

        # Create time array       
        t = np.arange(self.eeg_channel_data.shape[1]) / self.fs  # Create time base
        
        # Plot all selected channels in Time Domain
        colors = ['r', 'g', 'b', 'c', 'm', 'y', 'b', 'w']  # Colors for each channel
        
        if self.BoxFiltering.isChecked():
            self.eeg_channel_data_filt = eeg_filtering(self.eeg_channel_data,self.fs) 
        else:
            self.eeg_channel_data_filt = self.eeg_channel_data       

        if self.BoxTime.isChecked():
            self.TimeGraph.clear()  # Clear previous plots            
            for i, ch_index in enumerate(self.eeg_channel_indices):
                self.TimeGraph.plot(t, self.eeg_channel_data_filt[i, :] + i * 2000, pen=colors[ch_index % len(colors)])
            
        # Get Fourier and plot in Frequency Domain
        if self.BoxFFT.isChecked():
            self.freqs, self.psds = compute_fft_welch(self.eeg_channel_data_filt, self.fs)
            self.FFTGraph.clear()
            for i, ch_index in enumerate(self.eeg_channel_indices):
                self.FFTGraph.plot(self.freqs,self.psds[i,:],pen=colors[ch_index % len(colors)])

        # Get Power per Band
        if self.BoxPSD.isChecked():
            self.band_power = compute_power_bands(self.freqs,self.psds)       
            
            # Update pygame circle
            total_power = np.sum(self.band_power[1:])
            if total_power == 0:
                print("Total power is zero. Cannot compute ratio.")
                self.shared_beta_power = 0  # Or set to a default value
            else:
                if self.BoxTest.isChecked():
                    self.shared_beta_power = self.band_power[2] / total_power
                else: 
                    self.shared_beta_power = self.band_power[3] / total_power
            
            if np.isnan(self.shared_beta_power):
                print("Computed beta power ratio is NaN.")
                self.shared_beta_power = 0  # Handle NaN by setting to a default value

            self.PSD.clear()
            bar_graph_item = pg.BarGraphItem(x=[2,4,6,8,10], height=self.band_power, width=0.8, brush='b')
            self.PSD.addItem(bar_graph_item)
            
            # Update the x-axis to show categorical labels
            self.PSD.getAxis('bottom').setTicks([list(zip([2,4,6,8,10], self.bands))])

            if self.record_data:

                # Get the current timestamp
                timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                
                # Convert the numerical values in the vector to strings
                band_data = [str(value) for value in self.band_power]
                
                # Data
                data = [timestamp] + band_data
            
                # Define the header
                header = ['Time','Delta', 'Theta', 'Alpha', 'Beta', 'Gamma']

                # Check if the file exists and is empty
                file_exists = os.path.isfile(self.filename)
                is_empty = file_exists and os.path.getsize(self.filename) == 0

                # Open the file in append mode
                with open(self.filename, mode='a', newline='') as file:
                    writer = csv.writer(file)
                    # If the file is empty, write the header
                    if not file_exists or is_empty:
                        writer.writerow(header)
                    # Append the vector
                    writer.writerow(data)
                            

    def begin_recording(self):
        trial_name = self.trial_name.text()
        
        if not trial_name:
            self.label_6.setText("Please enter a trial name.")
            return
        
        # Set record data to true and initialize csv files
        self.record_data = True
        self.filename = os.path.join('.','results',trial_name+'_power.csv')
        with open(self.filename, mode='w', newline='') as file:
            pass 
        self.label_6.setText("csv file created ... recoding data!")

    def end_recording(self):
        self.record_data = False
        self.label_6.setText("Data recorded :)")
    
    def stop_pygame(self):
        # Set a flag that will be checked in the pygame loop
        self.running = False
                
    def start_pygame_thread(self):
        self.pygame_thread = threading.Thread(target=self.run_pygame)  # Correct: pass reference, not call
        self.pygame_thread.daemon = True
        self.pygame_thread.start()
        
    def run_pygame(self):
        pygame.init()

        # Get the size of the current display 
        infoObject = pygame.display.Info()
        screen_width, screen_height = infoObject.current_w, infoObject.current_h
        #screen_width, screen_height = 300,200
        # Set the display mode to the full size of the screen
        screen = pygame.display.set_mode((screen_width, screen_height))

        self.running = True
        min_radius = 10   # Maximum radius when beta power is high
        max_radius = 0.9*screen_height/2  # Minimum radius when beta power is low
        current_radius = max_radius

        num_points = 200  # Number of points to calculate along the circle
        max_offset = 5#15   # Maximum offset for the target position
        movement_speed = 0.01  # Movement speed towards the target
        radius_adjust_speed = 0.02  # Speed at which the main circle radius adjusts

        # Initialize points and their target offsets
        points = np.array([(np.cos(2 * np.pi / num_points * i), np.sin(2 * np.pi / num_points * i)) for i in range(num_points)])
        target_offsets = np.random.uniform(-max_offset, max_offset, (num_points, 2))
        current_offsets = np.zeros((num_points, 2))

        # Example shared beta power; you should link this to your actual data
        self.shared_beta_power = 0.5

        while self.running:
            for event in pygame.event.get():
                if event.type is pygame.QUIT:
                    running = False
                    pygame.quit()
                    sys.exit()

            screen.fill((0, 0, 0))

            # Inverted update of the circle radius: higher beta decreases the radius
            target_radius = int((1 - self.shared_beta_power) * (max_radius - min_radius) + min_radius)
            current_radius += (target_radius - current_radius) * radius_adjust_speed

            # Update points positions
            for i in range(num_points):
                # Move current offsets towards the target offsets
                current_offsets[i] += (target_offsets[i] - current_offsets[i]) * movement_speed
                # If the point is very close to the target, reset the target
                if np.linalg.norm(target_offsets[i] - current_offsets[i]) < 0.5:
                    target_offsets[i] = np.random.uniform(-max_offset, max_offset, 2)

                # Calculate position of each point
                x = int(screen_width / 2 + (current_radius + current_offsets[i][0]) * points[i][0])
                y = int(screen_height / 2 + (current_radius + current_offsets[i][1]) * points[i][1])
                pygame.draw.circle(screen, (255, 255, 255), (x, y), 2)  # Draw small circles to form the wavy circle

            pygame.display.flip()
        else: 
            pygame.quit()

# Main block to run the application
if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)  # Create an instance of QApplication

    # Set dark theme styles for PyQtGraph and the application
    pg.setConfigOptions(background='k', foreground='w')
    app.setStyleSheet("""
        QWidget {
            color: #b1b1b1;
            background-color: #323232;
        }
        QLabel, QCheckBox, QPushButton {
            color: #ffffff;
        }
        QLineEdit {
            background-color: #505050;
            color: #ffffff;
            border: 1px solid #8f8f91;
            border-radius: 2px;
        }
        QPushButton {
            background-color: #5c5c5c;
            border-style: outset;
            border-width: 2px;
            border-radius: 10px;
            border-color: beige;
            font: bold 14px;
            padding: 1px;
        }
        QPushButton:pressed {
            background-color: #484848;
            border-style: inset;
        }
    """)

    main_window = MainApp()  # Use the MainApp class for managing the main window
    main_window.show()  # Show the main window
    sys.exit(app.exec_())  # Start the event loop and wait for the app to close